<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
</head>
<body id="demo">
<div id="demo_div"><h1>daikdhkasdakl</h1></div>
<div id="demo_div2">
<script type="text/javascript" src="sha1Hash.js"></script>
<script type="text/javascript" src="jsencrypt.js"></script>
<script type="text/javascript">

//orgin server will give this
var userPublicIP="76.181.12.12";

//these two should be retrived from browser storage after first time
var sequenceNumber="100";
var cookieId="myChrome";

var encrypt = new JSEncrypt();
encrypt.setPublicKey("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCwWCZGpRP90TpgNQXlcHoofVyiNtAzgqC4XHA2tndlfrD4xUIOuh04PsStVK70GFc0Uue0bAXpmYm7R2anPqSxrTr4Ga/GInpR0hgepr9e6Nka4uKgGGsPlzngZHVsPU3mSmL+EYrwy6F9bZLV/jFoi+2zrgqop+mZYSUD3Rxr5QIDAQAB");
var encrypted = encrypt.encrypt(cookieId);
console.log(encrypted);
var encryptedCookieID=encrypted;
var decrypt = new JSEncrypt();
var privateFile="MIICWwIBAAKBgQCwWCZGpRP90TpgNQXlcHoofVyiNtAzgqC4XHA2tndlfrD4xUIOuh04PsStVK70GFc0Uue0bAXpmYm7R2anPqSxrTr4Ga/GInpR0hgepr9e6Nka4uKgGGsPlzngZHVsPU3mSmL+EYrwy6F9bZLV/jFoi+2zrgqop+mZYSUD3Rxr5QIDAQABAoGAB1fUWDK9j18sCB+NHE2/uHnn5pVTvCFfYe3vekfE1wQciG9mXcigONxcQj95fY6Z6wLcxSWOZXjQRG0nuCUipHWt5hOw0CC0YEXI+5HGg4mXfEO9CY4KurfWNzMiZoq1G1cF3qX6WmkqAKwMaCfUhqIvXeKOr39KUX2900vrLS0CQQDkDN4TYcl0HnOfw4js8o+P4vb8SPXQNjrk327XX62/tN7Kt7I60isxTm/n+/Hz06kXnWMi82lwVrN1PLMuLL7fAkEAxfT+8+3CAMSnHdtCQpAuXUZD3jkcKBj+Gzxr+9Cjdshlw0jUV7TjqpuszUAxmMulfzICIKjsq0Fmbo0hhbXhuwJAItpUlmG7iCOfSCt6IbxwdG0bkjMUXl3rYk9DgWb+Bu59nj2034h/UWnLcIjw0XLnxNQo8o6A7spRYvmD6OqtwQJAAM87q6uxO2eSd2DKKJOGXQNIi8QYBWH0yA+7MVBtGrM/F0lY9PLca3ovfrdgfIt4pciCkbefICQoUxNoq69OuQJAD4+kOlRIhsv5cZhWU22uqpB6o88aqZcHQRbZiSIMACsxbgOhWJkTzPwvHbitx7WEwdLtCvJCxDHRfCCzXo/1uA==";
decrypt.setPrivateKey(privateFile);
var uncrypted = decrypt.decrypt(encrypted);
console.log(uncrypted);
var peerIP="http://76.181.55.138/";
var peerUrl="http://76.181.55.138/contents/";
var byteCount=0;

//for image,css,html,php duplicates check
var container={};
//provided key set
var k0=peerUrl+"silverware.jpg";
var k1=peerUrl+"pie-icon.gif";
var k2=peerUrl+"pie.jpg";
var k3=peerUrl+"w3c-html.png";
var k4=peerUrl+"w3c-css.png";
var k5=peerUrl+"recipe.css";
var k6=peerUrl+"TMNT.html";
var k7=peerUrl+"rancidbanner.png";
var k8=peerUrl+"overview.png";
var k9=peerUrl+"rottenlarge.png";
var k10=peerUrl+"rotten.gif";
var k11=peerUrl+"critic.gif";
var keyChain={};
keyChain[k0]="e3336e1f26b63716b8fb413bd1e8dae1180d74ce";
keyChain[k1]="cd9d95f3565d0689d6cc5baa8ad07c3c37b914ac";
keyChain[k2]="bec8fcdd77fbe0306a2b7578d7d137a5dfa6c4ee";
keyChain[k3]="a76683010d26baa591b7e3fd1b7df3f0e4c9682a";
keyChain[k4]="b2763388390d74d7cafcc9dc15cb489876115633";
keyChain[k5]="91f140756617197a6fd118e112314fffe132bdde";
keyChain[k6]="1400a01c5ec88e8da204ddd06008b323b91d2514";
keyChain[k7]="db6e43e9f68f5e4b9c2ddfa95e69cd5c06e7ece7";
keyChain[k8]="50b75a144e2161c93c9c5f4e2eefa8040c0ba200";
keyChain[k9]="fb89ad65cdb2fae0ee3b1c3de63b47a4ae1aec35";
keyChain[k10]="ca7d60b9c93dd583e112d0e8b60c9fd36b481d50";
keyChain[k11]="853db1c674f2c4dfdd2c41d4c1cff5f8b04df3c3";
keyChain["mainPage2"]="bc6d989e4c52ce277b6693b27358ccfc642d721d";
function keyCheck(key,value)
{
  if(keyChain[key]!=undefined)
  {
  	if(keyChain[key]==value)
    	return true;
  	else
    	return false;
  }
  else
  {
    keyChain[key]=value;
    console.log(key);
    console.log(value);
    return true;
  }
}

//assume the only file type of embedded object in a css is an image
function cssVerify(cssUrl)
{
    if(container[cssUrl]===undefined)
    {
    	var xhttp = new XMLHttpRequest();
    	xhttp.open("GET", cssUrl, false);
    	var elapsedTime;
    	var tp1=Date.now();
    	xhttp.send();
    	if (xhttp.readyState === XMLHttpRequest.DONE&&xhttp.status == 200) {
    		var tp2=Date.now();
    		elapsedTime=tp2-tp1;
    		console.log("cssUrl:"+cssUrl+" "+elapsedTime);
        	var text=xhttp.responseText;
        	byteCount+=text.length;
			if(!keyCheck(cssUrl, Sha1.hash(text)))
        	{
	 	 		container[cssUrl]="invalid css";
          		return false;
        	}
        	var myPattern=/url\(.*\)/g;
        	var matchResult=text.match(myPattern);
        	//assume url in css is a image and url is relative here
        	var relativeDeepUrl;
			var absoluteDeepUrl;
        	var i=0;
        	//for every url found, check if we've obtained, if not, download it.
        	for(i=0;i<matchResult.length;i++)
        	{
          		relativeDeepUrl=matchResult[i].substring(5,matchResult[i].length-2);
          		absoluteDeepUrl=peerUrl+relativeDeepUrl;
	  			if(!imgVerify(absoluteDeepUrl))
          		{
	    			container[cssUrl]="invalid css";
            		return false;
          		}
        	}
        	var cssResult;
        	if(matchResult!=null)
        	{
          		cssResult=text.replace(myPattern,function(match){
          			relativeDeepUrl=match.substring(5,match.length-2);
	  				absoluteDeepUrl=peerUrl+relativeDeepUrl;
          			var newPart="url("+container[absoluteDeepUrl]+")";
          			return newPart;
          		});
        	}
        	else
        	{
          		cssResult=text;
        	}
        	container[cssUrl]='data:text/css;charset=utf-8,'+encodeURIComponent(cssResult);
			return true;     
      	}
      	else
      	{
			console.log("css retrieve fails due to network!");
			container[cssUrl]="invalid css";
			return false;
      	}
      }
      else
      {
		if(container[cssUrl]==="invalid css")
			return false;
		else
			return true;
      }
}

function linkTagVerify(linkTag)
{
  if(linkTag.rel==="stylesheet")
  {
	var cssUrl=linkTag.href;
	if(cssVerify(cssUrl))
	{
		linkTag.href=container[cssUrl];
		return true;
	}
	else
	{
		return false;
	}
  }
  if(linkTag.rel==="short icon")
  {
     if(imgVerify(linkTag.href))
     {
       linkTag.href=container[linkTag.href];
       return true;
     }
     else
     {
	return false;
     }
  }
  console.log("the thing in a link tag is not css or short icon!");
  return false;
}

function imgVerify(imgUrl)
{
    if(container[imgUrl]===undefined)
    {
    	var xhttp = new XMLHttpRequest();
    	xhttp.open("GET", imgUrl, true);
    	xhttp.overrideMimeType('text/plain; charset=x-user-defined');
		xhttp.onreadystatechange=function()
		{
			console.log(imgUrl+" before key check!!");
    		if (xhttp.status == 200) {
      			var imgOriginArray=xhttp.response;
      			byteCount+=imgOriginArray.length;
      			var imgByteArray=new Uint8Array(imgOriginArray.length);
      			var i;
      			var temp;
      			var result;
      			for(i=0;i<imgOriginArray.length;i++)
      			{
        			imgByteArray[i]=imgOriginArray.charCodeAt(i);
     			}
      			result=String.fromCharCode(imgByteArray[0]);
     			for(i=1;i<imgByteArray.length;i++)
      			{
        			temp=String.fromCharCode(imgByteArray[i]);
        			result=result+temp;
      			}
      			if(!keyCheck(imgUrl, Sha1.hash(result)))
      			{
					//container[imgUrl]="invalid image";
        			console.log(imgUrl+" is a invalid image!");
      			}
      			else
      			{
					console.log(imgUrl+" is a valid image!!!!!!!");
				}
				if(imgUrl==="http://76.181.55.138/contents/pie.jpg")
        		{
        			var onePie=document.getElementById("one");
        			onePie.src="http://76.181.55.138/contents/dota2.jpg";
        		}
    		}
			else
			{
				console.log("retrive image from network fails ! "+imgUrl);
			}
		};
		xhttp.send();
		container[imgUrl]=imgUrl;
		return true;
    }
    else
    {
		if(container[imgUrl]==="invalid image")
		{
			return false;
		}
		else
		{
			return true;
		}
    }
}

function getFileType(fileUrl)
{
	if(fileUrl.endsWith(".html")||fileUrl.endsWith(".php"))
		return 0;
	else if(fileUrl.endsWith(".gif")||fileUrl.endsWith(".png")||fileUrl.endsWith(".jpg"))
		return 1;
	else if(fileUrl.endsWith(".css"))
		return 2;
	else
		return 3;
}

//it is better to be called htmlPageVerify
function frameVerify(frameUrl)
{
	if(container[frameUrl]===undefined)
        {
    	var xhttp = new XMLHttpRequest();
    	xhttp.open("GET", frameUrl, false);
    	xhttp.send();
    	if (xhttp.readyState === XMLHttpRequest.DONE&&xhttp.status == 200) {
        	var text=xhttp.responseText;
		if(!keyCheck(frameUrl,Sha1.hash(text)))
			return false;
        	//match src="" only, not src='' and assume urls in src are relative urls
		//there could be script file in this page, not yet implemnt handler for it now
		var imgTagPattern=/<img src=(\"|\').*\.(png|jpg|gif)(\"|\')/g;
		var linkTagPattern=/<link href=(\"|\').*\.(png|jpg|gif|css)(\"|\')/g;
        	var matchResult=text.match(imgTagPattern);
		var extendedFrame1;
		var extendedFrame2;
        	var relativeDeepUrl;
        	var absoluteDeepUrl;
        	var i=0;
        	//for every url found, check if we've obtained, if not, download it.
        	for(i=0;i<matchResult.length;i++)
        	{
          		relativeDeepUrl=matchResult[i].substring(10,matchResult[i].length-1);
          		absoluteDeepUrl=peerUrl+relativeDeepUrl;
          		if(!imgVerify(absoluteDeepUrl))
				return false;
        	}
		//to optimize, it can be changeed to fetch one, verify one, replace one
		if(matchResult!=null)
        	{
          		extendedFrame1=text.replace(imgTagPattern,function(match){
          			var newPart;
				relativeDeepUrl=match.substring(10,match.length-1);
          			absoluteDeepUrl=peerUrl+relativeDeepUrl;
                		newPart='<img src="'+container[absoluteDeepUrl]+'"';
          			return newPart;
          		});
        	}
        	else
        	{
         		 extendedFrame1=text;
        	}
		matchResult=text.match(linkTagPattern);
		for(i=0;i<matchResult.length;i++)
        	{
          		relativeDeepUrl=matchResult[i].substring(12,matchResult[i].length-1);
          		absoluteDeepUrl=peerUrl+relativeDeepUrl;
			if(relativeDeepUrl.endsWith("css"))
			{
          			if(!cssVerify(absoluteDeepUrl))
					return false;
			}
			else
			{
				if(!imgVerify(absoluteDeepUrl))
					return false;
			}
        	}
        	if(matchResult!=null)
        	{
          		extendedFrame2=extendedFrame1.replace(linkTagPattern,function(match){
          			var newPart;
				relativeDeepUrl=match.substring(12,match.length-1);
          			absoluteDeepUrl=peerUrl+relativeDeepUrl;
                		newPart='<link href="'+container[absoluteDeepUrl]+'"';
          			return newPart;
          		});
        	}
        	else
        	{
         		 extendedFrame2=extendedFrame1;
        	}
        	container[frameUrl]='data:text/html;charset=utf-8,'+encodeURIComponent(extendedFrame2);
		return true;     
    	}
	else
	{
		console.log("network problem for retriving html");
		return false;
	}
    }
    else
    {
	//not store invalid script because once find a invalid script, whole program will stop
	return true;
    }
}

//both src and href value in the script will be replaced
function scriptVerify(scriptUrl)
{
    if(container[scriptUrl]===undefined)
    {
    	var xhttp = new XMLHttpRequest();
    	xhttp.open("GET", scriptUrl, false);
    	xhttp.send();
    	if (xhttp.readyState === XMLHttpRequest.DONE&&xhttp.status == 200) {
        	var text=xhttp.responseText;
		if(!keyCheck(scriptUrl,Sha1.hash(text)))
			return false;
        	//match src="" only, not src='' and assume urls in src are relative urls
		var myPattern=/src=\".*\";/g;
        	var matchResult=text.match(myPattern);
		var extendedScript=text;
        	var relativeDeepUrl;
        	var absoluteDeepUrl;
        	var i=0;
        	var embedFileType;
        	//for every url found, check if we've obtained, if not, download it.
        	for(i=0;i<matchResult.length;i++)
        	{
          		relativeDeepUrl=matchResult[i].substring(5,matchResult[i].length-2);
          		absoluteDeepUrl=peerUrl+relativeDeepUrl;
	  		embedFileType=getFileType(absoluteDeepUrl);
	  		if(embedFileType===0)
	  		{
				if(!frameVerify(absoluteDeepUrl))
					return false;
	  		}
	  		else if(embedFileType===1)
	  		{
          			if(!imgVerify(absoluteDeepUrl))
					return false;
	  		}
	  		else if(embedFileType===2)
          		{
				if(!cssVerify(absoluteDeepUrl))
					return false;
          		}
	  		else 
          		{
				//contains url of unknown type;
				return false;
	  		}
        	}
        	if(matchResult!=null)
        	{
          		extendedScript=text.replace(myPattern,function(match){
          			var newPart;
				relativeDeepUrl=match.substring(5,match.length-2);
          			absoluteDeepUrl=peerUrl+relativeDeepUrl;
                		newPart='src="'+container[absoluteDeepUrl]+'";';
          			return newPart;
          		});
        	}
        	else
        	{
         		 extendedScript=text;
        	}
        	container[scriptUrl]='data:text/javascript;charset=utf-8,'+encodeURIComponent(extendedScript);
		return true;     
    	}
	else
	{
		console.log("network problem for retriving script");
		return false;
	}
    }
    else
    {
	//not store invlid script because once find a invalid script, whole program will stop
	return true;
    }
}

var suffixIndex=peerUrl.length;
//assume external script,css,images
//need to change the above script,css,frame,image handler to handle inline situation
//now only handle external situation
function retrieveElements(sourceText)
{
  //assume all these elements are not inline
  var linkTags=sourceText.getElementsByTagName("link");
  var imgTags=sourceText.getElementsByTagName("img");
  var sTags=sourceText.getElementsByTagName("script");
  for(var i=0;i<sTags.length;i++)
  {
      //dom parser change relative url to peerURL+relativeURL automatically
      //do it again here just for clearity
      console.log("in pie.html script parse: "+sTags[i].src);
      var suffix=sTags[i].src.substring(suffixIndex);
      var temp=peerUrl+suffix;
      if(scriptVerify(temp))
	      sTags[i].src=container[temp];
      else
	      return false;
  }
  for(var i=0;i<linkTags.length;i++)
  {
      var suffix=linkTags[i].href.substring(suffixIndex);
      console.log(linkTags[i].href);
      var temp=peerUrl+suffix;
      linkTags[i].href=temp;
      if(!linkTagVerify(linkTags[i]))
        return false;
  }
  for(var i=0;i<imgTags.length;i++)
  {
      var suffix=imgTags[i].src.substring(suffixIndex);
      console.log(imgTags[i].src);
      var temp=peerUrl+suffix;
      imgTags[i].src=temp;
      if(imgVerify(imgTags[i].src))
        imgTags[i].src=container[temp];
      else
        return false;
  }
  return true;
}

function retrieveOrigin()
{
   var xhttp=new XMLHttpRequest();
   xhttp.onreadystatechange=function()
   {
     if (xhttp.readyState == 4 && xhttp.status == 200) {
     document.write(xhttp.response.documentElement.outerHTML);
     }
     else
     {
       console.log("fail page failed to fetch!");
     }
   }
   xhttp.open("GET","http://54.201.12.230/fail.html",true);
   xhttp.send();
}

function loadDoc() {
  var xhttp = new XMLHttpRequest();
  xhttp.responseType="document";
  xhttp.onreadystatechange = function() {
    if (xhttp.readyState == 4 && xhttp.status == 200) {
      byteCount+=xhttp.response.documentElement.outerHTML.length;
      if(!keyCheck("mainPage", Sha1.hash(xhttp.response.documentElement.outerHTML)))
      {
         console.log("in verify main!"); 
         retrieveOrigin();
      }
      else
      {
        if(!retrieveElements(xhttp.response))
        {
          console.log("in retriveElments!");
          //retrieveOrigin();
        }
        else
        {
          console.log("sum: "+byteCount);
          var uploader=new XMLHttpRequest();
          var content=sequenceNumber+userPublicIP+byteCount;
          var encryptedContent=encrypt.encrypt(content);
          var message='{"nounce":"'+sequenceNumber+'","userPublicIP":"'+userPublicIP
          +'","byteCount":"'+byteCount+'","encryptedCookieID":"'+encryptedCookieID+
          '","encryptedContent":"'+encryptedContent+'"}';
          uploader.open("GET",peerIP+"recorder.php?myMessage="+message,true);
          console.log("message:"+message);
          uploader.send();
          document.write(xhttp.response.documentElement.outerHTML);
        }
      }
    }
  };
  xhttp.open("GET", peerUrl+"pie.html", true);
  xhttp.send();
}
loadDoc();
</script>
</div>
</body>
</html>
